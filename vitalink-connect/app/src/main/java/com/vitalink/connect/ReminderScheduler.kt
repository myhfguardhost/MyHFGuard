package com.vitalink.connect

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.SystemClock
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject

object ReminderScheduler {
    fun startSchedule(context: Context) {
        val am = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
        val intent = Intent(context, SyncReceiver::class.java)
        val pi = PendingIntent.getBroadcast(context, 777, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        try { am.cancel(pi) } catch (_: Exception) {}
        val interval = AlarmManager.INTERVAL_HOUR // 1 hour for production
        am.setInexactRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + interval, interval, pi)
    }

    fun refresh(context: Context, http: OkHttpClient, baseUrl: String, patientId: String) {
        val url = baseUrl + "/patient/reminders?patientId=" + java.net.URLEncoder.encode(patientId, "UTF-8")
        
        val spToken = context.getSharedPreferences("vitalink", Context.MODE_PRIVATE)
        val token = spToken.getString("supabaseAccessToken", "") ?: ""

        // Check time for Daily Notifications (9am, 3pm, 9pm MYT)
        checkDailyNotifications(context, http, baseUrl, patientId, token)

        val sp = context.getSharedPreferences("vitalink_reminders", Context.MODE_PRIVATE)
        val seenIds = sp.getStringSet("seen_ids", emptySet())?.toMutableSet() ?: mutableSetOf()
        var idsChanged = false

        try {
            val reqBuilder = Request.Builder().url(url).get()
            if (token.isNotEmpty()) {
                reqBuilder.header("Authorization", "Bearer $token")
            }
            val req = reqBuilder.build()
            val resp = http.newCall(req).execute()
            resp.use {
                if (it.code != 200) return
                val body = it.body?.string() ?: return
                val obj = JSONObject(body)
                val arr = obj.optJSONArray("reminders") ?: return
                for (i in 0 until arr.length()) {
                    val r = arr.getJSONObject(i)
                    val id = r.optString("id")
                    val title = r.optString("title")
                    val dateStr = r.optString("date")
                    val t = try {
                        if (android.os.Build.VERSION.SDK_INT >= 26) {
                            try {
                                java.time.OffsetDateTime.parse(dateStr).toInstant()
                            } catch (_: Exception) {
                                java.time.Instant.parse(dateStr)
                            }
                        } else {
                            null
                        }
                    } catch (_: Exception) { null }
                    if (t != null) {
                        // Check if the appointment is in the future
                        val isFuture = t.isAfter(java.time.Instant.now())
                        
                        // If it's a new ID we haven't seen before, AND it is in the future, notify user
                        if (!seenIds.contains(id) && isFuture) {
                            val zdt = t.atZone(ZoneId.systemDefault())
                            val fmt = DateTimeFormatter.ofPattern("dd/MM h:mma", Locale.getDefault())
                            val dStr = fmt.format(zdt)
                            val intent = Intent(context, ReminderReceiver::class.java)
                            intent.putExtra("title", "New Appointment")
                            intent.putExtra("body", "$title on $dStr")
                            context.sendBroadcast(intent)
                            seenIds.add(id)
                            idsChanged = true
                        }
                        
                        // Always try to schedule (scheduleFor handles future checks for reminders)
                        // If the date changed to future, scheduleFor will set the alarms correctly.
                        scheduleFor(context, id, title, t)
                    }
                }
            }
        } catch (_: Exception) {}
        
        if (idsChanged) {
            sp.edit().putStringSet("seen_ids", seenIds).apply()
        }

        try {
            val reqBuilder = Request.Builder().url(baseUrl + "/patient/medications?patientId=" + java.net.URLEncoder.encode(patientId, "UTF-8")).get()
            if (token.isNotEmpty()) {
                reqBuilder.header("Authorization", "Bearer $token")
            }
            val req = reqBuilder.build()
            val resp = http.newCall(req).execute()
            resp.use {
                if (it.code == 200) {
                    val body = it.body?.string() ?: "{}"
                    val obj = JSONObject(body)
                    val prefs = obj.optJSONObject("preferences") ?: JSONObject()
                    val hour = prefs.optInt("notify_hour", 9)
                    if (prefs.optBoolean("beta_blockers", false)) scheduleDaily(context, 11001, "Take Beta blockers", hour)
                    if (prefs.optBoolean("raas_inhibitors", false)) scheduleDaily(context, 11002, "Take RAAS inhibitors", hour)
                    if (prefs.optBoolean("mras", false)) scheduleDaily(context, 11003, "Take MRAs", hour)
                    if (prefs.optBoolean("sglt2_inhibitors", false)) scheduleDaily(context, 11004, "Take SGLT2 inhibitors", hour)
                    if (prefs.optBoolean("statin", false)) scheduleDaily(context, 11005, "Take Statin", hour)
                }
            }
        } catch (_: Exception) {}

        runCatching {
            scheduleDaily(context, 12001, "Measure weight", 8)
            scheduleDaily(context, 12002, "Measure blood pressure", 21)
        }
    }

    fun sendTestNotifications(context: Context, patientId: String) {
        val base = context.getString(R.string.web_app_url).removeSuffix("/")
        val selfCheckUrl = "$base/self-check?patientId=" + java.net.URLEncoder.encode(patientId, "UTF-8")
        val bpUrl = "$base/vitals?patientId=" + java.net.URLEncoder.encode(patientId, "UTF-8")
        runCatching {
            val i1 = Intent(context, ReminderReceiver::class.java)
            i1.putExtra("title", "Daily Self Check")
            i1.putExtra("body", "Log your weight and symptoms today.")
            i1.putExtra("url", selfCheckUrl)
            context.sendBroadcast(i1)
        }
        runCatching {
            val i2 = Intent(context, ReminderReceiver::class.java)
            i2.putExtra("title", "Blood Pressure")
            i2.putExtra("body", "Please record today's BP reading.")
            i2.putExtra("url", bpUrl)
            context.sendBroadcast(i2)
        }
    }

    private fun checkDailyNotifications(context: Context, http: OkHttpClient, baseUrl: String, patientId: String, token: String) {
        val sp = context.getSharedPreferences("vitalink_daily_checks", Context.MODE_PRIVATE)
        val now = java.time.ZonedDateTime.now(ZoneId.of("Asia/Kuala_Lumpur"))
        val todayStr = now.toLocalDate().toString()
        val hour = now.hour

        if (hour == 9 && !sp.getBoolean("notified_9am_$todayStr", false)) {
            notifyOpenWeb(context, "Daily Health Log", "Please log your weight, BP, and symptoms today.", patientId, todayStr, 1001)
            sp.edit().putBoolean("notified_9am_$todayStr", true).apply()
        }

        if (hour == 15 && !sp.getBoolean("notified_3pm_$todayStr", false)) {
            val status = getDailyStatus(http, baseUrl, patientId, token, todayStr)
            val baseWeb = context.getString(R.string.web_app_url).removeSuffix("/")
            if (!status.hasWeight) {
                val url = "$baseWeb/self-check?patientId=" + java.net.URLEncoder.encode(patientId, "UTF-8")
                notifyLink(context, "Log Weight", "Please log your weight today.", url, 10021)
            }
            if (!status.hasBp) {
                val url = "$baseWeb/vitals?patientId=" + java.net.URLEncoder.encode(patientId, "UTF-8")
                notifyLink(context, "Record Blood Pressure", "Please record today's BP reading.", url, 10022)
            }
            if (!status.hasSymptoms) {
                val url = "$baseWeb/self-check?patientId=" + java.net.URLEncoder.encode(patientId, "UTF-8") + "&tab=symptoms"
                notifyLink(context, "Log Symptoms", "Please log today's symptoms.", url, 10023)
            }
            sp.edit().putBoolean("notified_3pm_$todayStr", true).apply()
        }

        if (hour == 21 && !sp.getBoolean("notified_9pm_$todayStr", false)) {
            notifyOpenWeb(context, "End of Day Chart", "View your hourly health chart for today.", patientId, todayStr, 1003)
            sp.edit().putBoolean("notified_9pm_$todayStr", true).apply()
        }
    }

    private fun checkDailyDataLogged(http: OkHttpClient, baseUrl: String, patientId: String, token: String, dateStr: String): Boolean {
        try {
            val url = "$baseUrl/patient/daily-status?patientId=$patientId&date=$dateStr"
            val req = Request.Builder().url(url).header("Authorization", "Bearer $token").get().build()
            http.newCall(req).execute().use { resp ->
                if (resp.code == 200) {
                    val json = JSONObject(resp.body?.string() ?: "{}")
                    return json.optBoolean("has_weight") && json.optBoolean("has_bp") && json.optBoolean("has_symptoms")
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return false
    }

    private data class DailyStatus(val hasWeight: Boolean, val hasBp: Boolean, val hasSymptoms: Boolean)
    private fun getDailyStatus(http: OkHttpClient, baseUrl: String, patientId: String, token: String, dateStr: String): DailyStatus {
        try {
            val url = "$baseUrl/patient/daily-status?patientId=$patientId&date=$dateStr"
            val req = Request.Builder().url(url).header("Authorization", "Bearer $token").get().build()
            http.newCall(req).execute().use { resp ->
                if (resp.code == 200) {
                    val json = JSONObject(resp.body?.string() ?: "{}")
                    return DailyStatus(
                        json.optBoolean("has_weight"),
                        json.optBoolean("has_bp"),
                        json.optBoolean("has_symptoms"),
                    )
                }
            }
        } catch (_: Exception) { }
        return DailyStatus(false, false, false)
    }

    private fun notifyOpenWeb(context: Context, title: String, body: String, patientId: String, dateStr: String, requestCode: Int) {
        val base = context.getString(R.string.web_app_url)
        val url = "$base/dashboard?patientId=" + java.net.URLEncoder.encode(patientId, "UTF-8") + "&date=" + java.net.URLEncoder.encode(dateStr, "UTF-8") + "#vitals"
        val intent = Intent(Intent.ACTION_VIEW, android.net.Uri.parse(url))
        val pi = PendingIntent.getActivity(context, requestCode, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
        val channelId = "vitalink_reminders_v2"
        if (nm.getNotificationChannel(channelId) == null) {
            val ch = android.app.NotificationChannel(channelId, "Vitalink Reminders", android.app.NotificationManager.IMPORTANCE_HIGH)
            nm.createNotificationChannel(ch)
        }
        val n = androidx.core.app.NotificationCompat.Builder(context, channelId)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(title)
            .setContentText(body)
            .setPriority(androidx.core.app.NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setContentIntent(pi)
            .build()
        nm.notify(requestCode, n)
    }

    private fun notifyLink(context: Context, title: String, body: String, url: String, requestCode: Int) {
        val intent = Intent(Intent.ACTION_VIEW, android.net.Uri.parse(url))
        val pi = PendingIntent.getActivity(context, requestCode, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
        val channelId = "vitalink_reminders_v2"
        if (nm.getNotificationChannel(channelId) == null) {
            val ch = android.app.NotificationChannel(channelId, "Vitalink Reminders", android.app.NotificationManager.IMPORTANCE_HIGH)
            nm.createNotificationChannel(ch)
        }
        val n = androidx.core.app.NotificationCompat.Builder(context, channelId)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(title)
            .setContentText(body)
            .setPriority(androidx.core.app.NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setContentIntent(pi)
            .build()
        nm.notify(requestCode, n)
    }

    private fun scheduleFor(context: Context, id: String, title: String, eventInstant: java.time.Instant) {
        val am = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
        val now = java.time.Instant.now().toEpochMilli()
        val eventMs = eventInstant.toEpochMilli()
        
        val zdt = eventInstant.atZone(ZoneId.systemDefault())
        val fmt = DateTimeFormatter.ofPattern("dd/MM h:mma", Locale.getDefault())
        val dStr = fmt.format(zdt)
        val body = "$title on $dStr"

        val pairs = listOf(
            24 * 60 * 60 * 1000L to "Appointment tomorrow",
            60 * 60 * 1000L to "Appointment in 1 hour",
            5 * 60 * 1000L to "Appointment in 5 minutes",
            0L to "Appointment now"
        )
        for ((offset, prefix) in pairs) {
            val fireAt = eventMs - offset
            if (fireAt > now) {
                val pi = pending(context, id + "|" + offset, prefix, body)
                try { am.cancel(pi) } catch (_: Exception) {}
                setExact(am, fireAt, pi)
            }
        }
    }

    private fun pending(context: Context, key: String, prefix: String, title: String): PendingIntent {
        val intent = Intent(context, ReminderReceiver::class.java)
        intent.putExtra("title", prefix)
        intent.putExtra("body", title)
        val req = key.hashCode()
        return PendingIntent.getBroadcast(context, req, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
    }

    private fun setExact(am: AlarmManager, whenMs: Long, pi: PendingIntent) {
        am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, whenMs, pi)
    }

    private fun scheduleDaily(context: Context, requestCode: Int, title: String, hour: Int) {
        val am = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
        val intent = Intent(context, ReminderReceiver::class.java)
        intent.putExtra("title", title)
        val pi = PendingIntent.getBroadcast(context, requestCode, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        try { am.cancel(pi) } catch (_: Exception) {}
        val cal = java.util.Calendar.getInstance()
        cal.set(java.util.Calendar.HOUR_OF_DAY, hour)
        cal.set(java.util.Calendar.MINUTE, 0)
        cal.set(java.util.Calendar.SECOND, 0)
        if (cal.timeInMillis < System.currentTimeMillis()) cal.add(java.util.Calendar.DAY_OF_YEAR, 1)
        am.setRepeating(AlarmManager.RTC_WAKEUP, cal.timeInMillis, AlarmManager.INTERVAL_DAY, pi)
    }
}

